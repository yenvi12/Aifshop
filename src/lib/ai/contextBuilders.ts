import { prisma } from '@/lib/prisma'

export interface ProductContext {
  id: string
  name: string
  price: number | null
  compareAtPrice: number | null
  description: string | null
  category: string
  images: string[]
  sizes: any[]
  rating: number | null
  stock: number
  badge: string | null
  reviews: any[]
  relatedProducts: any[]
}

export interface OrderContext {
  id: string
  orderNumber: string
  status: string
  totalAmount: number
  trackingNumber: string | null
  estimatedDelivery: Date | null
  orderItems: any[]
  shippingAddress: any
  createdAt: Date
}

export class ProductContextBuilder {
  static async buildContext(productId: string): Promise<string> {
    try {
      const product = await prisma.product.findUnique({
        where: { id: productId, isActive: true },
        select: {
          id: true,
          name: true,
          price: true,
          compareAtPrice: true,
          description: true,
          category: true,
          image: true,
          images: true,
          sizes: true,
          rating: true,
          stock: true,
          badge: true,
          reviews: {
            where: { isActive: true },
            take: 5,
            orderBy: { createdAt: 'desc' },
            include: {
              user: {
                select: {
                  firstName: true,
                  lastName: true
                }
              }
            }
          },
          _count: {
            select: { reviews: true }
          }
        }
      })

      if (!product) {
        return 'S·∫£n ph·∫©m kh√¥ng t√¨m th·∫•y ho·∫∑c ƒë√£ ng∆∞ng kinh doanh.'
      }

      console.log('Product data retrieved:', {
        id: product.id,
        name: product.name,
        hasDescription: !!product.description,
        descriptionLength: product.description?.length || 0,
        hasSizes: !!product.sizes,
        sizesCount: Array.isArray(product.sizes) ? product.sizes.length : 0,
        sizes: product.sizes
      });

      const relatedProducts = await this.getRelatedProducts(product.category, product.id)
      
      return this.formatProductContext(product, relatedProducts)
    } catch (error) {
      console.error('Error building product context:', error)
      return 'Kh√¥ng th·ªÉ t·∫£i th√¥ng tin s·∫£n ph·∫©m l√∫c n√†y.'
    }
  }

  private static async getRelatedProducts(category: string, currentProductId: string): Promise<any[]> {
    try {
      const relatedProducts = await prisma.product.findMany({
        where: {
          category,
          isActive: true,
          id: { not: currentProductId }
        },
        take: 3,
        select: {
          id: true,
          name: true,
          price: true,
          compareAtPrice: true,
          image: true,
          rating: true,
          badge: true,
          slug: true
        },
        orderBy: { rating: 'desc' }
      })

      return relatedProducts
    } catch (error) {
      console.error('Error fetching related products:', error)
      return []
    }
  }

  private static formatProductContext(product: any, relatedProducts: any[]): string {
    const discount = product.compareAtPrice && product.price 
      ? Math.round(((product.compareAtPrice - product.price) / product.compareAtPrice) * 100)
      : 0

    let context = `
üì¶ **TH√îNG TIN S·∫¢N PH·∫®M HI·ªÜN T·∫†I:**
- T√™n: ${product.name}
- Gi√°: ${product.price ? `${product.price.toLocaleString('vi-VN')}‚Ç´` : 'Li√™n h·ªá'}
${product.compareAtPrice ? `- Gi√° g·ªëc: ${product.compareAtPrice.toLocaleString('vi-VN')}‚Ç´` : ''}
${discount > 0 ? `- Gi·∫£m gi√°: ${discount}%` : ''}
- Danh m·ª•c: ${product.category}
- T·ªìn kho: ${product.stock} s·∫£n ph·∫©m
${product.badge ? `- Tags: ${product.badge}` : ''}

üìù **M√î T·∫¢ S·∫¢N PH·∫®M:**
${product.description || 'Kh√¥ng c√≥ m√¥ t·∫£ chi ti·∫øt.'}

üìè **TH√îNG TIN SIZE:**
${this.formatSizes(product.sizes)}

‚≠ê **ƒê√ÅNH GI√Å:**
- Rating: ${product.rating?.toFixed(1) || 'Ch∆∞a c√≥ ƒë√°nh gi√°'}/5
- S·ªë l∆∞·ª£ng ƒë√°nh gi√°: ${product._count?.reviews || 0}

üì∑ **H√åNH ·∫¢NH:**
S·∫£n ph·∫©m c√≥ ${product.images?.length || 0} h√¨nh ·∫£nh chi ti·∫øt.
`

    if (product.reviews && product.reviews.length > 0) {
      context += `
üí¨ **ƒê√ÅNH GI√Å G·∫¶N ƒê√ÇY:**
${this.formatRecentReviews(product.reviews)}
`
    }

    if (relatedProducts.length > 0) {
      context += `
üîó **S·∫¢N PH·∫®M LI√äN QUAN:**
${this.formatRelatedProducts(relatedProducts)}
`
    }

    return context
  }

  private static formatSizes(sizes: any[]): string {
    if (!sizes || sizes.length === 0) {
      return '- Kh√¥ng c√≥ th√¥ng tin size c·ª• th·ªÉ'
    }

    return sizes.map((size: any) => {
      const status = size.stock > 0 
        ? `C√≤n ${size.stock} s·∫£n ph·∫©m` 
        : 'H·∫øt h√†ng'
      return `- Size ${size.name}: ${status}`
    }).join('\n')
  }

  private static formatRecentReviews(reviews: any[]): string {
    return reviews.slice(0, 3).map((review: any) => {
      const userName = `${review.user.firstName} ${review.user.lastName}`
      const rating = '‚≠ê'.repeat(review.rating)
      return `- ${userName} (${rating}): "${review.comment}"`
    }).join('\n')
  }

  private static formatRelatedProducts(relatedProducts: any[]): string {
    return relatedProducts.map((product: any, index: number) => {
      const price = product.price ? `${product.price.toLocaleString('vi-VN')}‚Ç´` : 'Li√™n h·ªá'
      const rating = product.rating ? `${product.rating.toFixed(1)}/5` : 'Ch∆∞a c√≥ ƒë√°nh gi√°'
      return `${index + 1}. ${product.name} - ${price} (Rating: ${rating})`
    }).join('\n')
  }
}

export class OrderContextBuilder {
  static async buildOrderContext(userId: string): Promise<string> {
    console.log('Building order context for userId:', userId);
    
    try {
      // First check if user exists
      const user = await prisma.user.findUnique({
        where: { id: userId },
        select: { id: true, firstName: true, lastName: true, email: true }
      });
      
      if (!user) {
        console.log('User not found with id:', userId);
        // Try to find by supabaseUserId
        const userBySupabaseId = await prisma.user.findUnique({
          where: { supabaseUserId: userId },
          select: { id: true, firstName: true, lastName: true, email: true }
        });
        
        if (!userBySupabaseId) {
          return 'Kh√¥ng t√¨m th·∫•y th√¥ng tin ng∆∞·ªùi d√πng. Vui l√≤ng ƒëƒÉng nh·∫≠p l·∫°i.';
        }
        
        console.log('Found user by supabaseUserId, using actual userId:', userBySupabaseId.id);
        userId = userBySupabaseId.id;
      }

      console.log('Querying orders for userId:', userId);
      const orders = await prisma.order.findMany({
        where: { userId },
        orderBy: { createdAt: 'desc' },
        take: 5,
        include: {
          orderItems: {
            include: {
              product: {
                select: {
                  name: true,
                  image: true,
                  slug: true
                }
              }
            }
          },
          payment: true
        }
      })

      console.log('Found orders count:', orders.length);
      
      if (orders.length === 0) {
        return 'B·∫°n ch∆∞a c√≥ ƒë∆°n h√†ng n√†o.';
      }

      return this.formatOrderContext(orders)
    } catch (error) {
      console.error('Error building order context:', error)
      console.error('Error details:', {
        message: error instanceof Error ? error.message : 'Unknown error',
        stack: error instanceof Error ? error.stack : 'No stack trace',
        userId: userId
      })
      return `Kh√¥ng th·ªÉ t·∫£i th√¥ng tin ƒë∆°n h√†ng l√∫c n√†y: ${error instanceof Error ? error.message : 'Unknown error'}`;
    }
  }

  private static formatOrderContext(orders: any[]): string {
    let context = `
üìã **TH√îNG TIN ƒê∆†N H√ÄNG C·ª¶A B·∫†N:**

`

    orders.forEach((order: any, index: number) => {
      const statusEmoji = this.getStatusEmoji(order.status)
      const statusText = this.getStatusText(order.status)
      
      context += `
${index + 1}. **ƒê∆°n h√†ng #${order.orderNumber}**
   - Tr·∫°ng th√°i: ${statusEmoji} ${statusText}
   - T·ªïng ti·ªÅn: ${order.totalAmount.toLocaleString('vi-VN')}‚Ç´
   - Ng√†y ƒë·∫∑t: ${order.createdAt.toLocaleDateString('vi-VN')}
   ${order.trackingNumber ? `- M√£ v·∫≠n chuy·ªÉn: ${order.trackingNumber}` : ''}
   ${order.estimatedDelivery ? `- D·ª± ki·∫øn giao: ${order.estimatedDelivery.toLocaleDateString('vi-VN')}` : ''}
   
   **S·∫£n ph·∫©m trong ƒë∆°n:**
   ${order.orderItems.map((item: any) => 
     `‚Ä¢ ${item.product.name} ${item.size ? `(Size ${item.size})` : ''} - SL: ${item.quantity}`
   ).join('\n   ')}
`
    })

    return context
  }

  private static getStatusEmoji(status: string): string {
    const statusMap: Record<string, string> = {
      'ORDERED': 'üìù',
      'CONFIRMED': '‚úÖ',
      'PROCESSING': '‚öôÔ∏è',
      'SHIPPED': 'üöö',
      'DELIVERED': '‚ú®',
      'CANCELLED': '‚ùå'
    }
    return statusMap[status] || 'üìù'
  }

  private static getStatusText(status: string): string {
    const statusMap: Record<string, string> = {
      'ORDERED': 'ƒê√£ ƒë·∫∑t h√†ng',
      'CONFIRMED': 'ƒê√£ x√°c nh·∫≠n',
      'PROCESSING': 'ƒêang x·ª≠ l√Ω',
      'SHIPPED': 'ƒêang giao h√†ng',
      'DELIVERED': 'ƒê√£ giao h√†ng',
      'CANCELLED': 'ƒê√£ h·ªßy'
    }
    return statusMap[status] || status
  }
}

export class ProductListContextBuilder {
  static async buildProductListContext(limit: number = 10, categories?: string[]): Promise<string> {
    try {
      console.log('Building product list context with limit:', limit, 'categories:', categories);
      
      // Build query parameters
      const queryParams = new URLSearchParams();
      queryParams.append('limit', limit.toString());
      queryParams.append('status', 'active');
      
      if (categories && categories.length > 0) {
        // For now, we'll use the first category if multiple are provided
        queryParams.append('category', categories[0]);
      }

      // Fetch products from API
      const response = await fetch(`${process.env.NEXT_PUBLIC_BASE_URL || 'http://localhost:3000'}/api/products?${queryParams.toString()}`, {
        cache: 'no-store' // Always fetch fresh data
      });

      if (!response.ok) {
        console.error('Failed to fetch products:', response.status, response.statusText);
        return 'Kh√¥ng th·ªÉ t·∫£i danh s√°ch s·∫£n ph·∫©m l√∫c n√†y. Vui l√≤ng th·ª≠ l·∫°i sau.';
      }

      const result = await response.json();

      if (!result.success || !result.data || result.data.length === 0) {
        return 'Hi·ªán t·∫°i kh√¥ng c√≥ s·∫£n ph·∫©m n√†o trong danh m·ª•c n√†y. Vui l√≤ng ch·ªçn danh m·ª•c kh√°c ho·∫∑c li√™n h·ªá hotline ƒë·ªÉ ƒë∆∞·ª£c t∆∞ v·∫•n.';
      }

      const products = result.data;
      console.log('Fetched products count:', products.length);

      return this.formatProductListContext(products, categories);
    } catch (error) {
      console.error('Error building product list context:', error);
      return 'Kh√¥ng th·ªÉ t·∫£i danh s√°ch s·∫£n ph·∫©m l√∫c n√†y. Vui l√≤ng th·ª≠ l·∫°i sau.';
    }
  }

  private static formatProductListContext(products: any[], categories?: string[]): string {
    let context = `
üè™ **DANH S√ÅCH S·∫¢N PH·∫®M AIFShop** ${categories ? `(Danh m·ª•c: ${categories[0]})` : '(T·∫•t c·∫£ s·∫£n ph·∫©m)'}

Hi·ªán t·∫°i shop ƒëang c√≥ ${products.length} s·∫£n ph·∫©m ƒë·∫πp. D∆∞·ªõi ƒë√¢y l√† danh s√°ch chi ti·∫øt:

`;

    products.forEach((product: any, index: number) => {
      const price = product.price ? `${product.price.toLocaleString('vi-VN')}‚Ç´` : 'Li√™n h·ªá';
      const discount = product.compareAtPrice && product.price
        ? Math.round(((product.compareAtPrice - product.price) / product.compareAtPrice) * 100)
        : 0;
      
      context += `
${index + 1}. **${product.name}**
   - Gi√°: ${price}
   ${product.compareAtPrice ? `- Gi√° g·ªëc: ${product.compareAtPrice.toLocaleString('vi-VN')}‚Ç´` : ''}
   ${discount > 0 ? `- Gi·∫£m gi√°: ${discount}%` : ''}
   - Danh m·ª•c: ${product.category}
   ${product.badge ? `- Tags: ${product.badge}` : ''}
   ${product.rating ? `- Rating: ${product.rating.toFixed(1)}/5‚≠ê` : ''}
   - Link: /products/${product.slug}
   ${product.description ? `- M√¥ t·∫£: ${product.description.substring(0, 100)}...` : ''}
`;

      // Add size information if available
      if (product.sizes && Array.isArray(product.sizes) && product.sizes.length > 0) {
        const availableSizes = product.sizes.filter((size: any) => size.stock > 0);
        if (availableSizes.length > 0) {
          context += `   - Size c√≥ s·∫µn: ${availableSizes.map((size: any) => size.name).join(', ')}\n`;
        }
      }
    });

    context += `
üí° **G·ª¢I √ù:**
- Nh·∫≠p s·ªë th·ª© t·ª± c·ªßa s·∫£n ph·∫©m ƒë·ªÉ xem chi ti·∫øt
- Nh·∫≠p "t∆∞ v·∫•n [t√™n s·∫£n ph·∫©m]" ƒë·ªÉ ƒë∆∞·ª£c t∆∞ v·∫•n k·ªπ h∆°n
- Nh·∫≠p "size [t√™n s·∫£n ph·∫©m]" ƒë·ªÉ ƒë∆∞·ª£c t∆∞ v·∫•n size ph√π h·ª£p
- Nh·∫≠p "gi√° [t√™n s·∫£n ph·∫©m]" ƒë·ªÉ xem th√¥ng tin gi√° v√† khuy·∫øn m√£i

üîó **ƒêI·ªÄU H∆Ø·ªöNG:**
- Click v√†o link s·∫£n ph·∫©m ƒë·ªÉ xem chi ti·∫øt v√† ƒë·∫∑t h√†ng
- Ho·∫∑c n√≥i v·ªõi t√¥i t√™n s·∫£n ph·∫©m b·∫°n quan t√¢m ƒë·ªÉ t√¥i gi√∫p b·∫°n!

üìû **H·ªó tr·ª£:** Hotline 1900-xxxx (8:00 - 22:00 m·ªói ng√†y)
`;

    return context;
  }
}

export class GeneralContextBuilder {
  static buildGeneralContext(): string {
    return `
üè™ **TH√îNG TIN C·ª¨A H√ÄNG AIFShop:**
- Chuy√™n kinh doanh trang s·ª©c cao c·∫•p: nh·∫´n, d√¢y chuy·ªÅn, b√¥ng tai, v√≤ng tay
- Ch·∫•t li·ªáu: v√†ng 18K, 14K, b·∫°c 925, kim c∆∞∆°ng, ƒë√° qu√Ω
- D·ªãch v·ª•: t∆∞ v·∫•n size, b·∫£o h√†nh, ƒë·ªïi tr·∫£, mi·ªÖn ph√≠ v·∫≠n chuy·ªÉn
- Hotline h·ªó tr·ª£: 1900-xxxx
- Gi·ªù m·ªü c·ª≠a: 8:00 - 22:00 m·ªói ng√†y

üí° **G·ª¢I √ù T∆Ø V·∫§N:**
- T∆∞ v·∫•n size nh·∫´n d·ª±a tr√™n s·ªë ƒëo v√≤ng ng√≥n
- G·ª£i √Ω trang s·ª©c ph√π h·ª£p v·ªõi d√°ng ng∆∞·ªùi v√† phong c√°ch
- T∆∞ v·∫•n trang s·ª©c theo d·ªãp ƒë·∫∑c bi·ªát (c∆∞·ªõi, l·ªÖ, sinh nh·∫≠t)
- H∆∞·ªõng d·∫´n b·∫£o qu·∫£n trang s·ª©c ƒë√∫ng c√°ch
- Th√¥ng tin v·ªÅ ch√≠nh s√°ch b·∫£o h√†nh v√† ƒë·ªïi tr·∫£
`
  }
}
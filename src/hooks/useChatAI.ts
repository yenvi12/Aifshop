import { useState, useEffect, useCallback } from 'react';
import { Message } from '@/components/ai-chat';
import { useChatOptimization } from './useChatOptimization';

const CHAT_STORAGE_KEY = 'aifshop_chat_history';
const MAX_CHAT_HISTORY = 50;

interface UseChatAIOptions {
  maxHistory?: number;
  enablePersistence?: boolean;
  productContext?: {
    productId: string;
    productName: string;
    productCategory: string;
  };
}

export interface Suggestion {
  id: string;
  text: string;
  action: () => void;
  icon?: string;
  category?: 'product' | 'conversation' | 'general';
  priority?: number; // Lower number = higher priority (1 = product, 2 = conversation, 3 = general)
}

export function useChatAI(options: UseChatAIOptions = {}) {
  const {
    maxHistory = MAX_CHAT_HISTORY,
    enablePersistence = true
  } = options;

  const [messages, setMessages] = useState<Message[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  // Performance optimization
  const { optimizedChatCall, preloadCommonResponses } = useChatOptimization({
    debounceMs: 300,
    maxRetries: 2,
    cacheSize: 50
  });

  // Load chat history from localStorage
  useEffect(() => {
    if (!enablePersistence) return;

    try {
      const stored = localStorage.getItem(CHAT_STORAGE_KEY);
      if (stored) {
        const parsedMessages = JSON.parse(stored);
        // Convert string timestamps back to Date objects
        const messagesWithDates = parsedMessages.map((msg: any) => {
          console.log('Loading message from storage:', msg);
          // Validate content when loading from storage
          if (!msg.content || msg.content.trim() === '') {
            console.error('Loaded message with empty content from storage:', msg);
            msg.content = 'Tin nh·∫Øn tr·ªëng. Vui l√≤ng th·ª≠ l·∫°i.';
          }
          return {
            ...msg,
            timestamp: new Date(msg.timestamp)
          };
        });
        setMessages(messagesWithDates);
      }
    } catch (error) {
      console.error('Failed to load chat history:', error);
    }
  }, [enablePersistence]);

  // Save chat history to localStorage
  const saveChatHistory = useCallback((chatMessages: Message[]) => {
    if (!enablePersistence) return;

    try {
      const messagesToSave = chatMessages.slice(-maxHistory);
      localStorage.setItem(CHAT_STORAGE_KEY, JSON.stringify(messagesToSave));
    } catch (error) {
      console.error('Failed to save chat history:', error);
    }
  }, [enablePersistence, maxHistory]);

  // Add message to chat
  const addMessage = useCallback((message: Omit<Message, 'id' | 'timestamp'>) => {
    console.log('addMessage called with:', message);
    
    // Validate message content
    if (!message.content || message.content.trim() === '') {
      console.error('Attempted to add message with empty content:', message);
      // Set a default content if empty
      message.content = 'Tin nh·∫Øn tr·ªëng. Vui l√≤ng th·ª≠ l·∫°i.';
    }
    
    const newMessage: Message = {
      ...message,
      id: Date.now().toString(),
      timestamp: new Date()
    };

    console.log('Created new message:', newMessage);

    setMessages(prev => {
      const updated = [...prev, newMessage];
      saveChatHistory(updated);
      return updated;
    });

    return newMessage;
  }, [saveChatHistory]);

  // Clear chat history
  const clearChatHistory = useCallback(() => {
    setMessages([]);
    if (enablePersistence) {
      localStorage.removeItem(CHAT_STORAGE_KEY);
    }
  }, [enablePersistence]);

  // Send message to AI
  const sendMessage = useCallback(async (content: string, productId?: string) => {
    if (!content.trim()) return;

    setIsLoading(true);
    setError(null);

    // Add user message
    const userMessage = addMessage({
      content: content.trim(),
      role: 'user'
    });

    try {
      const token = localStorage.getItem('accessToken');
      if (!token) {
        throw new Error('Vui l√≤ng ƒëƒÉng nh·∫≠p ƒë·ªÉ s·ª≠ d·ª•ng chat AI');
      }

      // Generate context for caching
      const context = messages.slice(-3).map(msg => msg.content).join('|');
      console.log('Generated context for caching:', context);
      console.log('Sending productId to API:', productId);

      // Call AI API directly with product context
      const response = await fetch('/api/ai/chat', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`
        },
        body: JSON.stringify({
          message: content,
          conversationHistory: messages,
          productId: productId,
          context: productId ? 'product-specific' : 'general'
        })
      });

      if (!response.ok) {
        throw new Error('Kh√¥ng th·ªÉ k·∫øt n·ªëi v·ªõi AI');
      }

      const data = await response.json();

      if (!data.success) {
        throw new Error(data.error || 'AI response failed');
      }

      const aiResponse = data.response;
      console.log('Received AI response:', aiResponse);

      // Add AI response
      if (!aiResponse || aiResponse.trim() === '') {
        console.error('AI response is empty or invalid:', aiResponse);
        const fallbackResponse = 'Xin l·ªói, t√¥i kh√¥ng th·ªÉ x·ª≠ l√Ω y√™u c·∫ßu c·ªßa b·∫°n l√∫c n√†y. Vui l√≤ng th·ª≠ l·∫°i sau.';
        addMessage({
          content: fallbackResponse,
          role: 'assistant'
        });
        return fallbackResponse;
      }

      addMessage({
        content: aiResponse,
        role: 'assistant'
      });

      return aiResponse;
    } catch (err) {
      console.error('Error in sendMessage:', err);
      
      // Handle AbortError specifically - don't show error to user
      if (err instanceof Error && err.name === 'AbortError') {
        console.log('Request was aborted, not showing error to user');
        return;
      }
      
      const errorMessage = err instanceof Error ? err.message : 'ƒê√£ c√≥ l·ªói x·∫£y ra';
      
      // Only set error and show fallback message for non-abort errors
      setError(errorMessage);
      
      // Add error message from AI
      const fallbackMessage = 'Xin l·ªói, t√¥i ƒëang g·∫∑p s·ª± c·ªë k·ªπ thu·∫≠t. Vui l√≤ng th·ª≠ l·∫°i sau ho·∫∑c li√™n h·ªá hotline ƒë·ªÉ ƒë∆∞·ª£c h·ªó tr·ª£ nhanh nh·∫•t.';
      console.log('Adding error message to chat:', fallbackMessage);
      addMessage({
        content: fallbackMessage,
        role: 'assistant'
      });

      throw err;
    } finally {
      setIsLoading(false);
    }
  }, [messages, addMessage]);

  // Get product-specific suggestions when productContext is available
  const getProductSuggestions = useCallback((): Suggestion[] => {
    if (!options.productContext) return [];
    
    const { productName, productCategory } = options.productContext;
    return [
      {
        id: 'product-detail',
        text: `Chi ti·∫øt ${productName}`,
        action: () => sendMessage(`T∆∞ v·∫•n chi ti·∫øt v·ªÅ ${productName}`),
        icon: 'üíé',
        category: 'product',
        priority: 1
      },
      {
        id: 'product-size',
        text: 'T∆∞ v·∫•n size ph√π h·ª£p',
        action: () => sendMessage(`T∆∞ v·∫•n size ph√π h·ª£p cho ${productName}`),
        icon: 'üìè',
        category: 'product',
        priority: 1
      },
      {
        id: 'product-compare',
        text: 'So s√°nh s·∫£n ph·∫©m t∆∞∆°ng t·ª±',
        action: () => sendMessage(`Cho t√¥i xem c√°c s·∫£n ph·∫©m t∆∞∆°ng t·ª± v·ªõi ${productName}`),
        icon: 'üîç',
        category: 'product',
        priority: 1
      },
      {
        id: 'product-care',
        text: 'C√°ch b·∫£o qu·∫£n',
        action: () => sendMessage(`H∆∞·ªõng d·∫´n c√°ch b·∫£o qu·∫£n ${productName}`),
        icon: '‚ú®',
        category: 'product',
        priority: 1
      },
      {
        id: 'product-styling',
        text: 'C√°ch ph·ªëi ƒë·ªì',
        action: () => sendMessage(`T∆∞ v·∫•n c√°ch ph·ªëi ƒë·ªì v·ªõi ${productName}`),
        icon: 'üëó',
        category: 'product',
        priority: 1
      }
    ];
  }, [options.productContext, sendMessage]);

  // Get conversation-aware suggestions based on recent messages
  const getConversationSuggestions = useCallback((): Suggestion[] => {
    if (messages.length === 0) return [];
    
    const lastMessage = messages[messages.length - 1];
    if (!lastMessage || lastMessage.role !== 'assistant' || !lastMessage.content) {
      return [];
    }

    const content = lastMessage.content.toLowerCase();
    const suggestions: Suggestion[] = [];

    // Size/ring related
    if (content.includes('nh·∫´n') || content.includes('size')) {
      suggestions.push(
        {
          id: 'measure-ring',
          text: 'C√°ch ƒëo size nh·∫´n',
          action: () => sendMessage('H∆∞·ªõng d·∫´n chi ti·∫øt c√°ch ƒëo size nh·∫´n t·∫°i nh√†'),
          icon: 'üìê',
          category: 'conversation',
          priority: 2
        },
        {
          id: 'ring-materials',
          text: 'Ch·∫•t li·ªáu nh·∫´n',
          action: () => sendMessage('C√°c ch·∫•t li·ªáu l√†m nh·∫´n ph·ªï bi·∫øn v√† ∆∞u nh∆∞·ª£c ƒëi·ªÉm'),
          icon: 'üíç',
          category: 'conversation',
          priority: 2
        },
        {
          id: 'size-conversion',
          text: 'B·∫£ng quy ƒë·ªïi size',
          action: () => sendMessage('Cho t√¥i xem b·∫£ng quy ƒë·ªïi size nh·∫´n qu·ªëc t·∫ø'),
          icon: 'üìä',
          category: 'conversation',
          priority: 2
        }
      );
    }

    // Necklace related
    if (content.includes('d√¢y chuy·ªÅn') || content.includes('necklace')) {
      suggestions.push(
        {
          id: 'necklace-length',
          text: 'ƒê·ªô d√†i d√¢y chuy·ªÅn',
          action: () => sendMessage('T∆∞ v·∫•n ch·ªçn ƒë·ªô d√†i d√¢y chuy·ªÅn ph√π h·ª£p'),
          icon: 'üìø',
          category: 'conversation',
          priority: 2
        },
        {
          id: 'necklace-style',
          text: 'Phong c√°ch d√¢y chuy·ªÅn',
          action: () => sendMessage('C√°c phong c√°ch d√¢y chuy·ªÅn ƒëang th·ªãnh h√†nh'),
          icon: '‚ú®',
          category: 'conversation',
          priority: 2
        }
      );
    }

    // Product listing related
    if (content.includes('danh s√°ch s·∫£n ph·∫©m') || content.includes('s·∫£n ph·∫©m ƒëang c√≥')) {
      suggestions.push(
        {
          id: 'category-products',
          text: 'Xem theo danh m·ª•c',
          action: () => sendMessage('Cho t√¥i xem s·∫£n ph·∫©m theo t·ª´ng danh m·ª•c ri√™ng'),
          icon: 'üìÇ',
          category: 'conversation',
          priority: 2
        },
        {
          id: 'price-range',
          text: 'Theo kho·∫£ng gi√°',
          action: () => sendMessage('T√¥i mu·ªën t√¨m s·∫£n ph·∫©m trong kho·∫£ng gi√° c·ª• th·ªÉ'),
          icon: 'üí∞',
          category: 'conversation',
          priority: 2
        },
        {
          id: 'new-products',
          text: 'S·∫£n ph·∫©m m·ªõi',
          action: () => sendMessage('Cho t√¥i xem c√°c s·∫£n ph·∫©m m·ªõi nh·∫•t'),
          icon: 'üÜï',
          category: 'conversation',
          priority: 2
        }
      );
    }

    // Price related
    if (content.includes('gi√°') || content.includes('gi√° c·∫£')) {
      suggestions.push(
        {
          id: 'payment-methods',
          text: 'Ph∆∞∆°ng th·ª©c thanh to√°n',
          action: () => sendMessage('Cho t√¥i bi·∫øt c√°c ph∆∞∆°ng th·ª©c thanh to√°n'),
          icon: 'üí≥',
          category: 'conversation',
          priority: 2
        },
        {
          id: 'discount-policy',
          text: 'Ch√≠nh s√°ch gi·∫£m gi√°',
          action: () => sendMessage('Cho t√¥i bi·∫øt ch√≠nh s√°ch gi·∫£m gi√° hi·ªán t·∫°i'),
          icon: 'üéÅ',
          category: 'conversation',
          priority: 2
        }
      );
    }

    return suggestions;
  }, [messages, sendMessage]);

  // Get default/general suggestions
  const getDefaultSuggestions = useCallback((): Suggestion[] => {
    return [
      {
        id: 'product-listing',
        text: 'Xem t·∫•t c·∫£ s·∫£n ph·∫©m',
        action: () => sendMessage('Cho t√¥i xem danh s√°ch t·∫•t c·∫£ s·∫£n ph·∫©m ƒëang c√≥.'),
        icon: 'üõçÔ∏è',
        category: 'general',
        priority: 3
      },
      {
        id: 'ring-sizing',
        text: 'T∆∞ v·∫•n size nh·∫´n',
        action: () => sendMessage('T∆∞ v·∫•n size nh·∫´n cho t√¥i. T√¥i kh√¥ng bi·∫øt size nh·∫´n c·ªßa m√¨nh.'),
        icon: 'üíç',
        category: 'general',
        priority: 3
      },
      {
        id: 'necklace-guide',
        text: 'Ch·ªçn d√¢y chuy·ªÅn',
        action: () => sendMessage('Gi√∫p t√¥i ch·ªçn d√¢y chuy·ªÅn ph√π h·ª£p v·ªõi phong c√°ch c·ªßa t√¥i.'),
        icon: 'üìø',
        category: 'general',
        priority: 3
      },
      {
        id: 'order-history',
        text: 'L·ªãch s·ª≠ ƒë∆°n h√†ng',
        action: () => sendMessage('T√¥i mu·ªën xem l·ªãch s·ª≠ ƒë∆°n h√†ng c·ªßa m√¨nh.'),
        icon: 'üì¶',
        category: 'general',
        priority: 3
      },
      {
        id: 'care-tips',
        text: 'B·∫£o qu·∫£n trang s·ª©c',
        action: () => sendMessage('H∆∞·ªõng d·∫´n t√¥i c√°ch b·∫£o qu·∫£n trang s·ª©c ƒë√∫ng c√°ch.'),
        icon: '‚ú®',
        category: 'general',
        priority: 3
      },
      {
        id: 'gift-ideas',
        text: 'Qu√† t·∫∑ng trang s·ª©c',
        action: () => sendMessage('T√¥i c·∫ßn t∆∞ v·∫•n qu√† t·∫∑ng trang s·ª©c cho ng∆∞·ªùi th√¢n.'),
        icon: 'üéÅ',
        category: 'general',
        priority: 3
      }
    ];
  }, [sendMessage]);

  // Smart suggestions generator - combines product context, conversation context, and defaults
  // Always returns 4-6 suggestions sorted by priority to ensure consistent UI
  const getSmartSuggestions = useCallback((): Suggestion[] => {
    const allSuggestions: Suggestion[] = [];
    const usedIds = new Set<string>();

    // Priority 1: Product-specific suggestions (if available)
    const productSuggestions = getProductSuggestions();
    if (productSuggestions.length > 0) {
      // Take 2-3 product suggestions
      productSuggestions.slice(0, 3).forEach(suggestion => {
        if (!usedIds.has(suggestion.id)) {
          allSuggestions.push(suggestion);
          usedIds.add(suggestion.id);
        }
      });
    }

    // Priority 2: Conversation-aware suggestions (if there's conversation)
    const conversationSuggestions = getConversationSuggestions();
    if (conversationSuggestions.length > 0) {
      // Take 2-3 conversation suggestions
      conversationSuggestions.slice(0, 3).forEach(suggestion => {
        if (!usedIds.has(suggestion.id) && allSuggestions.length < 6) {
          allSuggestions.push(suggestion);
          usedIds.add(suggestion.id);
        }
      });
    }

    // Priority 3: Fill with default suggestions to ensure minimum 4 suggestions
    const defaultSuggestions = getDefaultSuggestions();
    defaultSuggestions.forEach(suggestion => {
      if (!usedIds.has(suggestion.id) && allSuggestions.length < 6) {
        allSuggestions.push(suggestion);
        usedIds.add(suggestion.id);
      }
    });

    // Sort by priority (lower number = higher priority), then take top 6
    const sorted = allSuggestions.sort((a, b) => {
      const priorityA = a.priority ?? 999;
      const priorityB = b.priority ?? 999;
      return priorityA - priorityB;
    });

    // Always return at least 4 suggestions, maximum 6
    return sorted.slice(0, 6);
  }, [getProductSuggestions, getConversationSuggestions, getDefaultSuggestions]);

  return {
    messages,
    isLoading,
    error,
    sendMessage,
    addMessage,
    clearChatHistory,
    suggestions: getSmartSuggestions(),
    hasHistory: messages.length > 1
  };
}